{"/home/travis/build/npmtest/node-npmtest-oauth2orize/test.js":"/* istanbul instrument in package npmtest_oauth2orize */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-oauth2orize/lib.npmtest_oauth2orize.js":"/* istanbul instrument in package npmtest_oauth2orize */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_oauth2orize = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_oauth2orize = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-oauth2orize/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-oauth2orize && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_oauth2orize */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_oauth2orize\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_oauth2orize.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_oauth2orize.rollup.js'] =\n            local.assetsDict['/assets.npmtest_oauth2orize.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_oauth2orize.__dirname + '/lib.npmtest_oauth2orize.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-oauth2orize/node_modules/oauth2orize/lib/index.js":"/**\n * Module dependencies.\n */\nvar fs = require('fs')\n  , path = require('path')\n  , Server = require('./server');\n\n\n/**\n * Create an OAuth 2.0 server.\n *\n * @return {Server}\n * @api public\n */\nfunction createServer(options) {\n  var server = new Server(options);\n  return server;\n}\n\n// expose createServer() as the module\nexports = module.exports = createServer;\n\n/**\n * Export `.createServer()`.\n */\nexports.createServer = createServer;\n\n\n/**\n * Export middleware.\n */\nexports.errorHandler = require('./middleware/errorHandler');\n\n/**\n * Auto-load bundled grants.\n */\nexports.grant = {};\n \nfs.readdirSync(__dirname + '/grant').forEach(function(filename) {\n  if (/\\.js$/.test(filename)) {\n    var name = path.basename(filename, '.js');\n    var load = function () { return require('./grant/' + name); };\n    exports.grant.__defineGetter__(name, load);\n  }\n});\n\n// alias grants\nexports.grant.authorizationCode = exports.grant.code;\nexports.grant.implicit = exports.grant.token;\n\n/**\n * Auto-load bundled exchanges.\n */\nexports.exchange = {};\n \nfs.readdirSync(__dirname + '/exchange').forEach(function(filename) {\n  if (/\\.js$/.test(filename)) {\n    var name = path.basename(filename, '.js');\n    var load = function () { return require('./exchange/' + name); };\n    exports.exchange.__defineGetter__(name, load);\n  }\n});\n\n// alias exchanges\nexports.exchange.code = exports.exchange.authorizationCode;\n\n/**\n * Export errors.\n */\nexports.OAuth2Error = require('./errors/oauth2error');\nexports.AuthorizationError = require('./errors/authorizationerror');\nexports.TokenError = require('./errors/tokenerror');\n","/home/travis/build/npmtest/node-npmtest-oauth2orize/node_modules/oauth2orize/lib/server.js":"/**\n * Module dependencies.\n */\nvar SessionStore = require('./txn/session')\n  , UnorderedList = require('./unorderedlist')\n  , authorization = require('./middleware/authorization')\n  , resume = require('./middleware/resume')\n  , decision = require('./middleware/decision')\n  , transactionLoader = require('./middleware/transactionLoader')\n  , token = require('./middleware/token')\n  , authorizationErrorHandler = require('./middleware/authorizationErrorHandler')\n  , errorHandler = require('./middleware/errorHandler')\n  , utils = require('./utils')\n  , debug = require('debug')('oauth2orize');\n\n\n/**\n * `Server` constructor.\n *\n * @api public\n */\nfunction Server(options) {\n  options = options || {};\n  this._reqParsers = [];\n  this._resHandlers = [];\n  this._errHandlers = [];\n  this._exchanges = [];\n\n  this._serializers = [];\n  this._deserializers = [];\n  this._txnStore = options.store || new SessionStore();\n}\n\n/**\n * Register authorization grant middleware.\n *\n * OAuth 2.0 defines an authorization framework, in which authorization grants\n * can be of a variety of types.  Initiating and responding to an OAuth 2.0\n * authorization transaction is implemented by grant middleware, and the server\n * registers the middleware it wishes to support.\n *\n * Examples:\n *\n *     server.grant(oauth2orize.grant.code());\n *\n *     server.grant('*', function(req) {\n *       return { host: req.headers['host'] }\n *     });\n *\n *     server.grant('foo', function(req) {\n *       return { foo: req.query['foo'] }\n *     });\n *\n * @param {String|Object} type\n * @param {String} phase\n * @param {Function} fn\n * @return {Server} for chaining\n * @api public\n */\nServer.prototype.grant = function(type, phase, fn) {\n  if (typeof type == 'object') {\n    // sig: grant(mod)\n    var mod = type;\n    if (mod.request) { this.grant(mod.name, 'request', mod.request); }\n    if (mod.response) { this.grant(mod.name, 'response', mod.response); }\n    if (mod.error) { this.grant(mod.name, 'error', mod.error); }\n    return this;\n  }\n  if (typeof phase == 'object') {\n    // sig: grant(type, mod)\n    var mod = phase;\n    if (mod.request) { this.grant(type, 'request', mod.request); }\n    if (mod.response) { this.grant(type, 'response', mod.response); }\n    if (mod.error) { this.grant(type, 'error', mod.error); }\n    return this;\n  }\n  \n  if (typeof phase == 'function') {\n    // sig: grant(type, fn)\n    fn = phase;\n    phase = 'request';\n  }\n  if (type === '*') { type = null; }\n  if (type) { type = new UnorderedList(type); }\n  \n  if (phase == 'request') {\n    debug('register request parser %s %s', type || '*', fn.name || 'anonymous');\n    this._reqParsers.push({ type: type, handle: fn });\n  } else if (phase == 'response') {\n    debug('register response handler %s %s', type || '*', fn.name || 'anonymous');\n    this._resHandlers.push({ type: type, handle: fn });\n  } else if (phase == 'error') {\n    debug('register error handler %s %s', type || '*', fn.name || 'anonymous');\n    this._errHandlers.push({ type: type, handle: fn });\n  }\n  return this;\n};\n\n/**\n * Register token exchange middleware.\n *\n * OAuth 2.0 defines an authorization framework, in which authorization grants\n * can be of a variety of types.  Exchanging of these types for access tokens is\n * implemented by exchange middleware, and the server registers the middleware\n * it wishes to support.\n *\n * Examples:\n *\n *     server.exchange(oauth2orize.exchange.authorizationCode(function() {\n *       ...\n *     }));\n *\n * @param {String|Function} type\n * @param {Function} fn\n * @return {Server} for chaining\n * @api public\n */\nServer.prototype.exchange = function(type, fn) {\n  if (typeof type == 'function') {\n    fn = type;\n    type = fn.name;\n  }\n  if (type === '*') { type = null; }\n  \n  debug('register exchanger %s %s', type || '*', fn.name || 'anonymous');\n  this._exchanges.push({ type: type, handle: fn });\n  return this;\n};\n\n/**\n * Parses requests to obtain authorization.\n *\n * @api public\n */\nServer.prototype.authorize =\nServer.prototype.authorization = function(options, validate, immediate) {\n  return authorization(this, options, validate, immediate);\n};\n\nServer.prototype.resume = function(options, immediate) {\n  if (options && options.loadTransaction === false) {\n    return resume(this, options, immediate);\n  }\n  return [transactionLoader(this, options), resume(this, options, immediate)];\n};\n\n/**\n * Handle a user's response to an authorization dialog.\n *\n * @api public\n */\nServer.prototype.decision = function(options, parse) {\n  if (options && options.loadTransaction === false) {\n    return decision(this, options, parse);\n  }\n  return [transactionLoader(this, options), decision(this, options, parse)];\n};\n\nServer.prototype.authorizeError =\nServer.prototype.authorizationError =\nServer.prototype.authorizationErrorHandler = function(options) {\n  var loader = transactionLoader(this, options);\n  \n  return [\n    function transactionLoaderErrorWrapper(err, req, res, next) {\n      loader(req, res, function(ierr) {\n        return next(err);\n      });\n    },\n    authorizationErrorHandler(this, options)\n  ];\n};\n\n/**\n * Handle requests to exchange an authorization grant for an access token.\n *\n * @api public\n */\nServer.prototype.token = function(options) {\n  return token(this, options);\n};\n\n/**\n * Respond to errors encountered in OAuth 2.0 endpoints.\n *\n * @api public\n */\nServer.prototype.errorHandler = function(options) {\n  return errorHandler(options);\n};\n\n/**\n * Registers a function used to serialize client objects into the session.\n *\n * Examples:\n *\n *     server.serializeClient(function(client, done) {\n *       done(null, client.id);\n *     });\n *\n * @api public\n */\nServer.prototype.serializeClient = function(fn, done) {\n  if (typeof fn === 'function') {\n    return this._serializers.push(fn);\n  }\n  \n  // private implementation that traverses the chain of serializers, attempting\n  // to serialize a client\n  var client = fn;\n  \n  var stack = this._serializers;\n  (function pass(i, err, obj) {\n    // serializers use 'pass' as an error to skip processing\n    if ('pass' === err) { err = undefined; }\n    // an error or serialized object was obtained, done\n    if (err || obj) { return done(err, obj); }\n    \n    var layer = stack[i];\n    if (!layer) {\n      return done(new Error('Failed to serialize client. Register serialization function using serializeClient().'));\n    }\n    \n    try {\n      layer(client, function(e, o) { pass(i + 1, e, o); } );\n    } catch (ex) {\n      return done(ex);\n    }\n  })(0);\n};\n\n/**\n * Registers a function used to deserialize client objects out of the session.\n *\n * Examples:\n *\n *     server.deserializeClient(function(id, done) {\n *       Client.findById(id, function (err, client) {\n *         done(err, client);\n *       });\n *     });\n *\n * @api public\n */\nServer.prototype.deserializeClient = function(fn, done) {\n  if (typeof fn === 'function') {\n    return this._deserializers.push(fn);\n  }\n  \n  // private implementation that traverses the chain of deserializers,\n  // attempting to deserialize a client\n  var obj = fn;\n  \n  var stack = this._deserializers;\n  (function pass(i, err, client) {\n    // deserializers use 'pass' as an error to skip processing\n    if ('pass' === err) { err = undefined; }\n    // an error or deserialized client was obtained, done\n    if (err || client) { return done(err, client); }\n    // a valid client existed when establishing the session, but that client has\n    // since been deauthorized\n    if (client === null || client === false) { return done(null, false); }\n    \n    var layer = stack[i];\n    if (!layer) {\n      return done(new Error('Failed to deserialize client. Register deserialization function using deserializeClient().'));\n    }\n    \n    try {\n      layer(obj, function(e, c) { pass(i + 1, e, c); } );\n    } catch (ex) {\n      return done(ex);\n    }\n  })(0);\n};\n\n\n/**\n * Parse authorization request into transaction using registered grant middleware. \n *\n * @param {String} type\n * @param {http.ServerRequest} req\n * @param {Function} cb\n * @api private\n */\nServer.prototype._parse = function(type, req, cb) {\n  var ultype = new UnorderedList(type)\n    , stack = this._reqParsers\n    , areq = {};\n  \n  if (type) { areq.type = type; }\n  \n  (function pass(i) {\n    var layer = stack[i];\n    if (!layer) { return cb(null, areq); }\n    \n    try {\n      debug('parse:%s', layer.handle.name || 'anonymous');\n      if (layer.type === null || layer.type.equalTo(ultype)) {\n        var arity = layer.handle.length;\n        if (arity == 1) { // sync\n          var o = layer.handle(req);\n          utils.merge(areq, o);\n          pass(i + 1);\n        } else { // async\n          layer.handle(req, function(err, o) {\n            if (err) { return cb(err); }\n            utils.merge(areq, o);\n            pass(i + 1);\n          });\n        }\n      } else {\n        pass(i + 1);\n      }\n    } catch (ex) {\n      return cb(ex);\n    }\n  })(0);\n};\n\n/**\n * Respond to authorization transaction using registered grant middleware. \n *\n * @param {Object} txn\n * @param {http.ServerResponse} res\n * @param {Function} cb\n * @api private\n */\nServer.prototype._respond = function(txn, res, complete, cb) {\n  if (cb === undefined) {\n    cb = complete;\n    complete = undefined;\n  }\n  \n  var ultype = new UnorderedList(txn.req.type)\n    , stack = this._resHandlers\n    , idx = 0;\n  \n  function next(err) {\n    if (err) { return cb(err); }\n    \n    var layer = stack[idx++];\n    if (!layer) { return cb(); }\n    \n    try {\n      debug('respond:%s', layer.handle.name || 'anonymous');\n      if (layer.type === null || layer.type.equalTo(ultype)) {\n        var arity = layer.handle.length;\n        if (arity == 4) {\n          layer.handle(txn, res, complete, next);\n        } else {\n          layer.handle(txn, res, next);\n        }\n      } else {\n        next();\n      }\n    } catch (ex) {\n      return cb(ex);\n    }\n  }\n  next();\n};\n\nServer.prototype._respondError = function(err, txn, res, cb) {\n  var ultype = new UnorderedList(txn.req.type)\n    , stack = this._errHandlers\n    , idx = 0;\n    \n  function next(err) {\n    var layer = stack[idx++];\n    if (!layer) { return cb(err); }\n  \n    try {\n      debug('error:%s', layer.handle.name || 'anonymous');\n      if (layer.type === null || layer.type.equalTo(ultype)) {\n        layer.handle(err, txn, res, next);\n      } else {\n        next(err);\n      }\n    } catch (ex) {\n      return cb(ex);\n    }\n  }\n  next(err);\n}\n\n/**\n * Process token request using registered exchange middleware. \n *\n * @param {String} type\n * @param {http.ServerRequest} req\n * @param {http.ServerResponse} res\n * @param {Function} cb\n * @api private\n */\nServer.prototype._exchange = function(type, req, res, cb) {\n  var stack = this._exchanges\n    , idx = 0;\n  \n  function next(err) {\n    if (err) { return cb(err); }\n    \n    var layer = stack[idx++];\n    if (!layer) { return cb(); }\n    \n    try {\n      debug('exchange:%s', layer.handle.name || 'anonymous');\n      if (layer.type === null || layer.type === type) {\n        layer.handle(req, res, next);\n      } else {\n        next();\n      }\n    } catch (ex) {\n      return cb(ex);\n    }\n  }\n  next();\n};\n\n\n/**\n * Expose `Server`.\n */\nexports = module.exports = Server;\n","/home/travis/build/npmtest/node-npmtest-oauth2orize/node_modules/oauth2orize/lib/txn/session.js":"/**\n * Module dependencies.\n */\nvar utils = require('../utils')\n  , AuthorizationError = require('../errors/authorizationerror')\n  , BadRequestError = require('../errors/badrequesterror')\n  , ForbiddenError = require('../errors/forbiddenerror');\n\n\nfunction SessionStore() {\n  this.legacy = true;\n}\n\nSessionStore.prototype.load = function(server, options, req, cb) {\n  var field = options.transactionField || 'transaction_id'\n    , key = options.sessionKey || 'authorize';\n  \n  if (!req.session) { return cb(new Error('OAuth2orize requires session support. Did you forget app.use(express.session(...))?')); }\n  if (!req.session[key]) { return cb(new ForbiddenError('Unable to load OAuth 2.0 transactions from session')); }\n  \n  var query = req.query || {}\n    , body = req.body || {}\n    , tid = query[field] || body[field];\n\n  if (!tid) { return cb(new BadRequestError('Missing required parameter: ' + field)); }\n  var txn = req.session[key][tid];\n  if (!txn) { return cb(new ForbiddenError('Unable to load OAuth 2.0 transaction: ' + tid)); }\n  \n  var self = this;\n  server.deserializeClient(txn.client, function(err, client) {\n    if (err) { return cb(err); }\n    if (!client) {\n      // At the time the request was initiated, the client was validated.\n      // Since then, however, it has been invalidated.  The transaction will\n      // be invalidated and no response will be sent to the client.\n      self.remove(options, req, tid, function(err) {\n        if (err) { return cb(err); }\n        return cb(new AuthorizationError('Unauthorized client', 'unauthorized_client'));\n      });\n      return;\n    }\n  \n    txn.transactionID = tid;\n    txn.client = client;\n    cb(null, txn);\n  });\n}\n\nSessionStore.prototype.store = function(server, options, req, txn, cb) {\n  var lenTxnID = options.idLength || 8\n    , key = options.sessionKey || 'authorize';\n    \n  if (!req.session) { return cb(new Error('OAuth2orize requires session support. Did you forget app.use(express.session(...))?')); }\n  \n  server.serializeClient(txn.client, function(err, obj) {\n    if (err) { return cb(err); }\n    \n    var tid = utils.uid(lenTxnID);\n    txn.client = obj;\n  \n    // store transaction in session\n    var txns = req.session[key] = req.session[key] || {};\n    txns[tid] = txn;\n  \n    cb(null, tid);\n  });\n}\n\nSessionStore.prototype.update = function(server, options, req, tid, txn, cb) {\n  var key = options.sessionKey || 'authorize';\n  \n  server.serializeClient(txn.client, function(err, obj) {\n    if (err) { return cb(err); }\n    \n    txn.client = obj;\n  \n    // store transaction in session\n    var txns = req.session[key] = req.session[key] || {};\n    txns[tid] = txn;\n  \n    cb(null, tid);\n  });\n}\n\nSessionStore.prototype.remove = function(options, req, tid, cb) {\n  var key = options.sessionKey || 'authorize';\n  \n  if (!req.session) { return cb(new Error('OAuth2orize requires session support. Did you forget app.use(express.session(...))?')); }\n  \n  if (req.session[key]) {\n    delete req.session[key][tid];\n  }\n  \n  cb();\n}\n\n\nmodule.exports = SessionStore;\n","/home/travis/build/npmtest/node-npmtest-oauth2orize/node_modules/oauth2orize/lib/utils.js":"exports.merge = require('utils-merge');\nexports.uid = require('uid2');\n","/home/travis/build/npmtest/node-npmtest-oauth2orize/node_modules/oauth2orize/lib/errors/authorizationerror.js":"/**\n * Module dependencies.\n */\nvar OAuth2Error = require('./oauth2error');\n\n/**\n * `AuthorizationError` error.\n *\n * @api public\n */\nfunction AuthorizationError(message, code, uri, status) {\n  if (!status) {\n    switch (code) {\n      case 'invalid_request': status = 400; break;\n      case 'unauthorized_client': status = 403; break;\n      case 'access_denied': status = 403; break;\n      case 'unsupported_response_type': status = 501; break;\n      case 'invalid_scope': status = 400; break;\n      case 'temporarily_unavailable': status = 503; break;\n    }\n  }\n  \n  OAuth2Error.call(this, message, code, uri, status);\n  Error.captureStackTrace(this, arguments.callee);\n  this.name = 'AuthorizationError';\n}\n\n/**\n * Inherit from `OAuth2Error`.\n */\nAuthorizationError.prototype.__proto__ = OAuth2Error.prototype;\n\n\n/**\n * Expose `AuthorizationError`.\n */\nmodule.exports = AuthorizationError;\n","/home/travis/build/npmtest/node-npmtest-oauth2orize/node_modules/oauth2orize/lib/errors/oauth2error.js":"/**\n * `OAuth2Error` error.\n *\n * @api public\n */\nfunction OAuth2Error(message, code, uri, status) {\n  Error.call(this);\n  this.message = message;\n  this.code = code || 'server_error';\n  this.uri = uri;\n  this.status = status || 500;\n}\n\n/**\n * Inherit from `Error`.\n */\nOAuth2Error.prototype.__proto__ = Error.prototype;\n\n\n/**\n * Expose `OAuth2Error`.\n */\nmodule.exports = OAuth2Error;\n","/home/travis/build/npmtest/node-npmtest-oauth2orize/node_modules/oauth2orize/lib/errors/badrequesterror.js":"/**\n * `BadRequestError` error.\n *\n * @api public\n */\nfunction BadRequestError(message) {\n  Error.call(this);\n  Error.captureStackTrace(this, arguments.callee);\n  this.name = 'BadRequestError';\n  this.message = message;\n  this.status = 400;\n}\n\n/**\n * Inherit from `Error`.\n */\nBadRequestError.prototype.__proto__ = Error.prototype;\n\n\n/**\n * Expose `BadRequestError`.\n */\nmodule.exports = BadRequestError;\n","/home/travis/build/npmtest/node-npmtest-oauth2orize/node_modules/oauth2orize/lib/errors/forbiddenerror.js":"/**\n * `ForbiddenError` error.\n *\n * @api public\n */\nfunction ForbiddenError(message) {\n  Error.call(this);\n  Error.captureStackTrace(this, arguments.callee);\n  this.name = 'ForbiddenError';\n  this.message = message;\n  this.status = 403;\n}\n\n/**\n * Inherit from `Error`.\n */\nForbiddenError.prototype.__proto__ = Error.prototype;\n\n\n/**\n * Expose `ForbiddenError`.\n */\nmodule.exports = ForbiddenError;\n","/home/travis/build/npmtest/node-npmtest-oauth2orize/node_modules/oauth2orize/lib/unorderedlist.js":"/**\n * `UnorderedList` constructor.\n *\n * @api public\n */\nfunction UnorderedList(items) {\n  if (typeof items == 'string') {\n    items = items.split(' ');\n  }\n  this._items = items || [];\n  this.__defineGetter__('length', this._length);\n}\n\n/**\n * Check if list is equal to `other` list.\n *\n * @param {UnorderedList} other\n * @return {Boolean}\n * @api public\n */\nUnorderedList.prototype.equalTo = function(other) {\n  if (!(other instanceof UnorderedList)) {\n    other = new UnorderedList(other);\n  }\n  \n  if (this.length != other.length) { return false; }\n  for (var i = 0, len = this._items.length; i < len; i++) {\n    var item = this._items[i];\n    if (other._items.indexOf(item) == -1) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Check if list contains `val`\n *\n * @param {String} val\n * @return {Boolean}\n * @api public\n */\nUnorderedList.prototype.contains = function(val) {\n  return this._items.indexOf(val) != -1;\n};\n\n/**\n * Check if list contains any element in `arr`\n *\n * @param {Array} arr\n * @return {Boolean}\n * @api public\n */\nUnorderedList.prototype.containsAny = function(arr) {\n  for (var i = 0, len = arr.length; i < len; i++) {\n    if (this._items.indexOf(arr[i]) != -1) { return true; }\n  }\n  return false;\n};\n\n/**\n * String representation of list.\n *\n * @return {String}\n * @api private\n */\nUnorderedList.prototype.toString = function() {\n  return this._items.join(' ');\n};\n\n/**\n * Length of list.\n *\n * @return {Number}\n * @api private\n */\nUnorderedList.prototype._length = function() {\n  return this._items.length;\n};\n\n/**\n * Expose `UnorderedList`.\n */\nmodule.exports = UnorderedList;\n","/home/travis/build/npmtest/node-npmtest-oauth2orize/node_modules/oauth2orize/lib/middleware/authorization.js":"/**\n * Module dependencies.\n */\nvar utils = require('../utils')\n  , AuthorizationError = require('../errors/authorizationerror');\n\n\n/**\n * Handle authorization requests from OAuth 2.0 clients.\n *\n * Obtaining authorization via OAuth 2.0 consists of a sequence of discrete\n * steps.  First, the client requests authorization from the user (in this case\n * using an authorization server as an intermediary).  The authorization server\n * conducts an approval dialog with the user to obtain permission.  After access\n * has been allowed, a grant is issued to the client which can be exchanged for\n * an access token.\n *\n * This middleware is used to initiate authorization transactions.  If a request\n * is parsed and validated, the following properties will be available on the\n * request:\n *\n *     req.oauth2.transactionID  an ID assigned to this transaction\n *     req.oauth2.client         client requesting the user's authorization\n *     req.oauth2.redirectURI    URL to redirect the user to after authorization\n *     req.oauth2.req            parameters from request made by the client\n *\n * The contents of `req.oauth2.req` depends on the grant type requested by the\n * the client.  The `server`'s request parsing functions are used to construct\n * this object, and the application can implement support for these types as\n * necessary, taking advantage of bundled grant middleware.\n *\n * Because the approval dialog may be conducted over a series of requests and\n * responses, a transaction is also stored in the session until a decision is\n * reached.  The application is responsible for verifying the user's identity\n * and prompting him or her to allow or deny the request (typically via an HTML\n * form).  At that point, `decision` middleware can be utilized to process the\n * user's decision and issue the grant to the client.\n *\n * Callbacks:\n *\n * This middleware requires a `validate` callback, for which the function\n * signature is as follows:\n *\n *     function(clientID, redirectURI, done) { ... }\n *\n * `clientID` is the client identifier and `redirectURI` is the redirect URI as\n * indicated by the client.  If the request is valid, `done` must be invoked\n * with the following signature:\n *\n *     done(err, client, redirectURI);\n *\n * `client` is the client instance which is making the request.  `redirectURI`\n * is the URL to which the user will be redirected after authorization is\n * obtained (which may be different, if the server is enforcing registration\n * requirements).  If an error occurs, `done` should be invoked with `err` set\n * in idomatic Node.js fashion.\n *\n * Alternate function signatures of the `validate` callback are available if\n * needed.  Consult the source code for a definitive reference.\n *\n *\n * Note that authorization may be obtained by the client directly from the user\n * without using an authorization server as an intermediary (for example, when\n * obtaining a grant in the form of the user's password credentials).  In these\n * cases, the client interacts only with the token endpoint without any need to\n * interact with the authorization endpoint.\n *\n * Options:\n *\n *     idLength    length of generated transaction IDs (default: 8)\n *     sessionKey  key under which transactions are stored in the session (default: 'authorize')\n *\n * Examples:\n *\n *     app.get('/dialog/authorize',\n *       login.ensureLoggedIn(),\n *       server.authorization(function(clientID, redirectURI, done) {\n *         Clients.findOne(clientID, function(err, client) {\n *           if (err) { return done(err); }\n *           if (!client) { return done(null, false); }\n *           return done(null, client, client.redirectURI);\n *         });\n *       }),\n *       function(req, res) {\n *         res.render('dialog', { transactionID: req.oauth2.transactionID,\n *                                user: req.user, client: req.oauth2.client });\n *       });\n *\n * References:\n *  - [Authorization Endpoint](http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-3.1)\n *\n * @param {Server} server\n * @param {Object} options\n * @param {Function} validate\n * @return {Function}\n * @api protected\n */\nmodule.exports = function(server, options, validate, immediate, complete) {\n  if (typeof options == 'function') {\n    complete = immediate;\n    immediate = validate;\n    validate = options;\n    options = undefined;\n  }\n  options = options || {};\n  immediate = immediate || function (client, user, done) { return done(null, false); };\n  \n  if (!server) { throw new TypeError('oauth2orize.authorization middleware requires a server argument'); }\n  if (!validate) { throw new TypeError('oauth2orize.authorization middleware requires a validate function'); }\n  \n  var userProperty = options.userProperty || 'user';\n  \n  return function authorization(req, res, next) {\n    \n    var body = req.body || {}\n      , type = req.query.response_type || body.response_type;\n\n    server._parse(type, req, function(err, areq) {\n      if (err) { return next(err); }\n      if (!areq || !areq.type) { return next(new AuthorizationError('Missing required parameter: response_type', 'invalid_request')); }\n      if (areq.type && !areq.clientID) { return next(new AuthorizationError('Unsupported response type: ' + type, 'unsupported_response_type')); }\n      \n      function validated(err, client, redirectURI) {\n        // Set properties *before* next()'ing due to error.  The presence of a\n        // redirectURI being provided, even under error conditions, indicates\n        // that the client should be informed of the error via a redirect.\n        req.oauth2 = {};\n        if (client) { req.oauth2.client = client; }\n        if (redirectURI) { req.oauth2.redirectURI = redirectURI; }\n        req.oauth2.req = areq;\n        req.oauth2.user = req[userProperty];\n        if (req.locals) { req.oauth2.locals = req.locals; }\n\n        if (err) { return next(err); }\n        if (!client) { return next(new AuthorizationError('Unauthorized client', 'unauthorized_client')); }\n\n        function immediated(err, allow, info, locals) {\n          if (err) { return next(err); }\n          if (allow) {\n            req.oauth2.res = info || {};\n            req.oauth2.res.allow = true;\n            if (locals) {\n              req.oauth2.locals = req.oauth2.locals || {};\n              utils.merge(req.oauth2.locals, locals);\n            }\n            \n            function completing(cb) {\n              if (!complete) { return cb(); }\n              complete(req, req.oauth2, cb);\n            }\n\n            server._respond(req.oauth2, res, completing, function(err) {\n              if (err) { return next(err); }\n              return next(new AuthorizationError('Unsupported response type: ' + req.oauth2.req.type, 'unsupported_response_type'));\n            });\n          } else {\n            // Add info and locals to `req.oauth2`, where they will be\n            // available to the next middleware.  Since this is a\n            // non-immediate response, the next middleware's responsibility is\n            // to prompt the user to allow or deny access.  `info` and\n            // `locals` are passed along as they may be of assistance when\n            // rendering the prompt.\n            //\n            // Note that, when using the legacy transaction store, `info` is\n            // also serialized into the transaction, where it can further be\n            // utilized in the `decision` middleware after the user submits the\n            // prompt's form.  As such, `info` should be a normal JSON object,\n            // so that it can be correctly serialized into the session.\n            // `locals` is only carried through to the middleware chain for the\n            // current request, so it may contain instantiated classes that\n            // don't serialize cleanly.\n            //\n            // The transaction store is pluggable when initializing the `Server`\n            // instance.  If an application implements a custom transaction\n            // store, the specific details of what properties are serialized\n            // into the transaction and loaded on subsequent requests are\n            // determined by the implementation.\n            req.oauth2.info = info;\n            if (locals) {\n              req.oauth2.locals = req.oauth2.locals || {};\n              utils.merge(req.oauth2.locals, locals);\n            }\n            \n            // A dialog needs to be conducted to obtain the user's approval.\n            // Serialize a transaction to the session.  The transaction will be\n            // restored (and removed) from the session when the user allows or\n            // denies the request.\n            function stored(err, tid) {\n              if (err) { return next(err); }\n              req.oauth2.transactionID = tid;\n              next();\n            }\n            \n            if (server._txnStore.legacy == true) {\n              var txn = {};\n              txn.protocol = 'oauth2';\n              txn.client = client;\n              txn.redirectURI = redirectURI;\n              txn.req = areq;\n              txn.info = info;\n              \n              server._txnStore.store(server, options, req, txn, stored);\n            } else {\n              server._txnStore.store(req, req.oauth2, stored);\n            }\n          }\n        }\n\n        var arity = immediate.length;\n        if (arity == 7) {\n          immediate(req.oauth2.client, req.oauth2.user, req.oauth2.req.scope, req.oauth2.req.type, req.oauth2.req, req.oauth2.locals, immediated);\n        } else if (arity == 6) {\n          immediate(req.oauth2.client, req.oauth2.user, req.oauth2.req.scope, req.oauth2.req.type, req.oauth2.req, immediated);\n        } else if (arity == 5) {\n          immediate(req.oauth2.client, req.oauth2.user, req.oauth2.req.scope, req.oauth2.req.type, immediated);\n        } else if (arity == 4) {\n          immediate(req.oauth2.client, req.oauth2.user, req.oauth2.req.scope, immediated);\n        } else { // arity == 3\n          immediate(req.oauth2.client, req.oauth2.user, immediated);\n        }\n      }\n      \n      try {\n        var arity = validate.length;\n        if (arity == 5) {\n          validate(areq.clientID, areq.redirectURI, areq.scope, areq.type, validated);\n        } else if (arity == 4) {\n          validate(areq.clientID, areq.redirectURI, areq.scope, validated);\n        } else if (arity == 3) {\n          validate(areq.clientID, areq.redirectURI, validated);\n        } else { // arity == 2\n          validate(areq, validated);\n        }\n      } catch (ex) {\n        return next(ex);\n      }\n    });\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-oauth2orize/node_modules/oauth2orize/lib/middleware/resume.js":"/**\n * Module dependencies.\n */\nvar utils = require('../utils')\n  , AuthorizationError = require('../errors/authorizationerror');\n\n\nmodule.exports = function(server, options, immediate, complete) {\n  if (typeof options == 'function') {\n    complete = immediate;\n    immediate = options;\n    options = undefined;\n  }\n  options = options || {};\n  \n  if (!server) { throw new TypeError('oauth2orize.resume middleware requires a server argument'); }\n  if (!immediate) { throw new TypeError('oauth2orize.resume middleware requires an immediate function'); }\n  \n  var userProperty = options.userProperty || 'user';\n  \n  return function resume(req, res, next) {\n    if (!req.oauth2) { return next(new Error('OAuth2orize requires transaction support. Did you forget oauth2orize.transactionLoader(...)?')); }\n    \n    req.oauth2.user = req[userProperty];\n    if (res.locals) {\n      req.oauth2.locals = req.oauth2.locals || {};\n      utils.merge(req.oauth2.locals, res.locals);\n    }\n    \n    function immediated(err, allow, info, locals) {\n      if (err) { return next(err); }\n      if (allow) {\n        req.oauth2.res = info || {};\n        req.oauth2.res.allow = true;\n        if (locals) {\n          req.oauth2.locals = req.oauth2.locals || {};\n          utils.merge(req.oauth2.locals, locals);\n        }\n        \n        // proxy end() to delete the transaction\n        var end = res.end;\n        res.end = function(chunk, encoding) {\n          if (server._txnStore.legacy == true) {\n            server._txnStore.remove(options, req, req.oauth2.transactionID, function noop(){});\n          } else {\n            server._txnStore.remove(req, req.oauth2.transactionID, function noop(){});\n          }\n    \n          res.end = end;\n          res.end(chunk, encoding);\n        };\n        req.oauth2._endProxied = true;\n\n        function completing(cb) {\n          if (!complete) { return cb(); }\n          complete(req, req.oauth2, cb);\n        }\n\n        server._respond(req.oauth2, res, completing, function(err) {\n          if (err) { return next(err); }\n          return next(new AuthorizationError('Unsupported response type: ' + req.oauth2.req.type, 'unsupported_response_type'));\n        });\n      } else {\n        req.oauth2.info = info;\n        if (locals) {\n          req.oauth2.locals = req.oauth2.locals || {};\n          utils.merge(req.oauth2.locals, locals);\n        }\n        \n        function updated(err, tid) {\n          if (err) { return next(err); }\n          req.oauth2.transactionID = tid;\n          next();\n        }\n        \n        if (server._txnStore.legacy == true) {\n          var txn = {};\n          txn.protocol = 'oauth2';\n          txn.client = req.oauth2.client;\n          txn.redirectURI = req.oauth2.redirectURI;\n          txn.req = req.oauth2.req;\n          txn.info = info;\n          \n          server._txnStore.update(server, options, req, req.oauth2.transactionID, txn, updated);\n        } else {\n          server._txnStore.update(req, req.oauth2.transactionID, req.oauth2, updated);\n        }\n      }\n    }\n    \n    try {\n      var arity = immediate.length;\n      if (arity == 7) {\n        immediate(req.oauth2.client, req.oauth2.user, req.oauth2.req.scope, req.oauth2.req.type, req.oauth2.req, req.oauth2.locals, immediated);\n      } else if (arity == 6) {\n        immediate(req.oauth2.client, req.oauth2.user, req.oauth2.req.scope, req.oauth2.req.type, req.oauth2.req, immediated);\n      } else if (arity == 5) {\n        immediate(req.oauth2.client, req.oauth2.user, req.oauth2.req.scope, req.oauth2.req.type, immediated);\n      } else if (arity == 4) {\n        immediate(req.oauth2.client, req.oauth2.user, req.oauth2.req.scope, immediated);\n      } else { // arity == 3\n        immediate(req.oauth2.client, req.oauth2.user, immediated);\n      }\n    } catch (ex) {\n      return next(ex);\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-oauth2orize/node_modules/oauth2orize/lib/middleware/decision.js":"/**\n * Module dependencies.\n */\nvar utils = require('../utils')\n  , AuthorizationError = require('../errors/authorizationerror')\n  , ForbiddenError = require('../errors/forbiddenerror');\n\n\n/**\n * Handle authorization decisions from resource owners.\n *\n * Obtaining authorization via OAuth 2.0 consists of a sequence of discrete\n * steps.  First, the client requests authorization from the user (in this case\n * using an authorization server as an intermediary).  The authorization server\n * conducts an approval dialog with the user to obtain permission.  After access\n * has been allowed, a grant is issued to the client which can be exchanged for\n * an access token.\n *\n * This middleware is used to process a user's decision about whether to allow\n * or deny access.  The client that initiated the authorization transaction will\n * be sent a response, including a grant if access was allowed.\n *\n * The exact form of the grant will depend on the type requested by the client.\n * The `server`'s response handling functions are used to issue the grant and\n * send the response.   An application can implement support for these types as\n * necessary, including taking advantage of bundled grant middleware.\n *\n * Callbacks:\n *\n * An optional `parse` callback can be passed as an argument, for which the\n * function signature is as follows:\n *\n *     function(req, done) { ... }\n *\n * `req` is the request, which can be parsed for any additional parameters found\n * in query as required by the service provider.  `done` is a callback which\n * must be invoked with the following signature:\n *\n *     done(err, params);\n *\n * `params` are the additional parameters parsed from the request.  These will\n * be set on the transaction at `req.oauth2.res`.  If an error occurs, `done`\n * should be invoked with `err` set in idomatic Node.js fashion.\n *\n * Options:\n *\n *     cancelField    name of field that is set if user denied access (default: 'cancel')\n *     userProperty   property of `req` which contains the authenticated user (default: 'user')\n *     sessionKey     key under which transactions are stored in the session (default: 'authorize')\n *\n * Examples:\n *\n *     app.post('/dialog/authorize/decision',\n *       login.ensureLoggedIn(),\n *       server.decision());\n *\n *     app.post('/dialog/authorize/decision',\n *       login.ensureLoggedIn(),\n *       server.decision(function(req, done) {\n *         return done(null, { scope: req.scope })\n *       }));\n *\n * @param {Server} server\n * @param {Object} options\n * @param {Function} parse\n * @return {Function}\n * @api protected\n */\nmodule.exports = function(server, options, parse, complete) {\n  if (typeof options == 'function') {\n    complete = parse;\n    parse = options;\n    options = undefined;\n  }\n  options = options || {};\n  parse = parse || function(req, done) { return done(); };\n  \n  if (!server) { throw new TypeError('oauth2orize.decision middleware requires a server argument'); }\n  \n  var cancelField = options.cancelField || 'cancel'\n    , userProperty = options.userProperty || 'user';\n  \n  return function decision(req, res, next) {\n    if (!req.body) { return next(new Error('OAuth2orize requires body parsing. Did you forget app.use(express.bodyParser())?')); }\n    if (!req.oauth2) { return next(new Error('OAuth2orize requires transaction support. Did you forget oauth2orize.transactionLoader(...)?')); }\n    \n    parse(req, function(err, ares, locals) {\n      if (err) { return next(err); }\n    \n      var tid = req.oauth2.transactionID;\n      req.oauth2.user = req[userProperty];\n      req.oauth2.res = ares || {};\n      if (locals) {\n        req.oauth2.locals = req.oauth2.locals || {};\n        utils.merge(req.oauth2.locals, locals);\n      }\n      \n      if (req.oauth2.res.allow === undefined) {\n        if (!req.body[cancelField]) { req.oauth2.res.allow = true; }\n        else { req.oauth2.res.allow = false; }\n      }\n    \n      // proxy end() to delete the transaction\n      var end = res.end;\n      res.end = function(chunk, encoding) {\n        if (server._txnStore.legacy == true) {\n          server._txnStore.remove(options, req, req.oauth2.transactionID, function noop(){});\n        } else {\n          server._txnStore.remove(req, req.oauth2.transactionID, function noop(){});\n        }\n        \n        res.end = end;\n        res.end(chunk, encoding);\n      };\n      req.oauth2._endProxied = true;\n      \n      function completing(cb) {\n        if (!complete) { return cb(); }\n        complete(req, req.oauth2, cb);\n      }\n      \n      server._respond(req.oauth2, res, completing, function(err) {\n        if (err) { return next(err); }\n        return next(new AuthorizationError('Unsupported response type: ' + req.oauth2.req.type, 'unsupported_response_type'));\n      });\n    });\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-oauth2orize/node_modules/oauth2orize/lib/middleware/transactionLoader.js":"/**\n * Module dependencies.\n */\nvar AuthorizationError = require('../errors/authorizationerror')\n  , BadRequestError = require('../errors/badrequesterror')\n  , ForbiddenError = require('../errors/forbiddenerror');\n\n\n/**\n * Loads an OAuth 2.0 authorization transaction from the session.\n *\n * This middleware is used to load a pending OAuth 2.0 transaction that is\n * serialized into the session.  In most circumstances, this is transparently\n * done prior to processing a user's decision with `decision` middleware, and an\n * implementation shouldn't need to mount this middleware explicitly.\n *\n * Options:\n *\n *     transactionField  name of field that contains the transaction ID (default: 'transaction_id')\n *     sessionKey        key under which transactions are stored in the session (default: 'authorize')\n *\n * @param {Server} server\n * @param {Object} options\n * @return {Function}\n * @api protected\n */\nmodule.exports = function(server, options) {\n  options = options || {};\n  \n  if (!server) { throw new TypeError('oauth2orize.transactionLoader middleware requires a server argument'); }\n  \n  return function transactionLoader(req, res, next) {\n    if (req.oauth2) { return next(); }\n    \n    function loaded(err, txn) {\n      if (err) { return next(err); }\n      req.oauth2 = txn;\n      next();\n    }\n    \n    if (server._txnStore.legacy == true) {\n      server._txnStore.load(server, options, req, loaded);\n    } else {\n      server._txnStore.load(req, loaded);\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-oauth2orize/node_modules/oauth2orize/lib/middleware/token.js":"/**\n * Module dependencies.\n */\nvar TokenError = require('../errors/tokenerror');\n\n\n/**\n * Exchanges authorization grants for access tokens.\n *\n * Obtaining authorization via OAuth 2.0 consists of a sequence of discrete\n * steps.  First, the client requests authorization from the user (in this case\n * using an authorization server as an intermediary).  The authorization server\n * conducts an approval dialog with the user to obtain permission.  After access\n * has been allowed, a grant is issued to the client which can be exchanged for\n * an access token.\n *\n * This middleware is used to exchange a previously issued authorization grant\n * for an access token (a string denoting a specific scope, lifetime, and other\n * access attributes).\n *\n * The types of the grants that can be exchanged will depend on the types\n * supported by the server.   An application can implement support for these\n * types as necessary, including taking advantage of bundled grant and exchange\n * middleware.\n *\n * Note that clients issued credentials must authenticate when when making\n * requests to the token endpoint.  This is essential for enforcing the binding\n * of authorization codes and refresh tokens to the client they were issued to.\n * Some client deployments may be incapable of secure client authentication.\n * Applications are responsible for determining what level of exposure is\n * acceptable, and handling such clients and displaying notices as appropriate.\n *\n * Examples:\n *\n *     app.post('/token',\n *       passport.authenticate(['basic', 'oauth2-client-password'], { session: false }),\n *       server.token(),\n *       server.errorHandler());\n *\n * References:\n *  - [Token Endpoint](http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-3.2)\n *\n * @param {Server} server\n * @param {Object} options\n * @return {Function}\n * @api protected\n */\nmodule.exports = function token(server, options) {\n  options = options || {};\n  \n  if (!server) { throw new TypeError('oauth2orize.token middleware requires a server argument'); }\n  \n  return function token(req, res, next) {\n    var type = req.body.grant_type;\n    \n    server._exchange(type, req, res, function(err) {\n      if (err) { return next(err); }\n      return next(new TokenError('Unsupported grant type: ' + type, 'unsupported_grant_type'));\n    });\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-oauth2orize/node_modules/oauth2orize/lib/errors/tokenerror.js":"/**\n * Module dependencies.\n */\nvar OAuth2Error = require('./oauth2error');\n\n/**\n * `TokenError` error.\n *\n * @api public\n */\nfunction TokenError(message, code, uri, status) {\n  if (!status) {\n    switch (code) {\n      case 'invalid_request': status = 400; break;\n      case 'invalid_client': status = 401; break;\n      case 'invalid_grant': status = 403; break;\n      case 'unauthorized_client': status = 403; break;\n      case 'unsupported_grant_type': status = 501; break;\n      case 'invalid_scope': status = 400; break;\n    }\n  }\n  \n  OAuth2Error.call(this, message, code, uri, status);\n  Error.captureStackTrace(this, arguments.callee);\n  this.name = 'TokenError';\n}\n\n/**\n * Inherit from `OAuth2Error`.\n */\nTokenError.prototype.__proto__ = OAuth2Error.prototype;\n\n\n/**\n * Expose `TokenError`.\n */\nmodule.exports = TokenError;\n","/home/travis/build/npmtest/node-npmtest-oauth2orize/node_modules/oauth2orize/lib/middleware/authorizationErrorHandler.js":"module.exports = function(server, options) {\n  options = options || {};\n  \n  if (!server) { throw new TypeError('oauth2orize.authorizationErrorHandler middleware requires a server argument'); }\n  \n  return function authorizationErrorHandler(err, req, res, next) {\n    if (!req.oauth2) { return next(err); }\n    \n    if (req.oauth2.transactionID && !req.oauth2._endProxied) {\n      // proxy end() to delete the transaction\n      var end = res.end;\n      res.end = function(chunk, encoding) {\n        if (server._txnStore.legacy == true) {\n          server._txnStore.remove(options, req, req.oauth2.transactionID, function noop(){});\n        } else {\n          server._txnStore.remove(req, req.oauth2.transactionID, function noop(){});\n        }\n      \n        res.end = end;\n        res.end(chunk, encoding);\n      };\n    }\n    \n    server._respondError(err, req.oauth2, res, function(err) {\n      return next(err);\n    });\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-oauth2orize/node_modules/oauth2orize/lib/middleware/errorHandler.js":"/**\n * Module dependencies.\n */\nvar url = require('url')\n  , qs = require('querystring')\n  , UnorderedList = require('../unorderedlist');\n\n\n/**\n * Handles errors encountered in OAuth 2.0 endpoints.\n *\n * This is error handling middleware intended for use in endpoints involved in\n * the OAuth 2.0 protocol.  If an error occurs while processing a request, this\n * middleware formats a response in accordance with the OAuth 2.0 specification.\n *\n * This middleware has two modes of operation: direct and indirect.  Direct mode\n * (the default) is intended to be used with the token endpoint, in which the\n * response can be sent directly to the client.  Indirect mode is intended to be\n * used with user authorization endpoints, in which the response must be issued\n * to the client indirectly via a redirect through the user's browser.\n *\n * Options:\n *   - `mode`   mode of operation, defaults to `direct`\n *\n * Examples:\n *\n *     app.post('/token',\n *       passport.authenticate(['basic', 'oauth2-client-password'], { session: false }),\n *       server.token(),\n *       server.errorHandler());\n *\n *    app.get('/dialog/authorize',\n *       login.ensureLoggedIn(),\n *       server.authorization( ... )\n *       server.errorHandler({ mode: 'indirect' }));\n *\n * References:\n *  - [Error Response](http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-5.2)\n *  - [Authorization Response](http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-4.1.2)\n *  - [Authorization Response](http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-4.2.2)\n *\n * @param {Object} options\n * @return {Function}\n * @api public\n */\nmodule.exports = function(options) {\n  options = options || {};\n  \n  var mode = options.mode || 'direct'\n    , fragment = options.fragment || ['token']\n    , modes = options.modes || {};\n  \n  if (!modes.query) {\n    modes.query = require('../response/query');\n  }\n  if (!modes.fragment) {\n    modes.fragment = require('../response/fragment');\n  }\n  \n  return function errorHandler(err, req, res, next) {\n    if (mode == 'direct') {\n      if (err.status) { res.statusCode = err.status; }\n      if (!res.statusCode || res.statusCode < 400) { res.statusCode = 500; }\n      \n      if (res.statusCode == 401) {\n        // TODO: set WWW-Authenticate header\n      }\n      \n      var e = {};\n      e.error = err.code || 'server_error';\n      if (err.message) { e.error_description = err.message; }\n      if (err.uri) { e.error_uri = err.uri; }\n      \n      res.setHeader('Content-Type', 'application/json');\n      return res.end(JSON.stringify(e));\n    } else if (mode == 'indirect') {\n      // If the redirectURI for this OAuth 2.0 transaction is invalid, the user\n      // agent will not be redirected and the client will not be informed.  `next`\n      // immediately into the application's error handler, so a message can be\n      // displayed to the user.\n      if (!req.oauth2 || !req.oauth2.redirectURI) { return next(err); }\n\n      var enc = 'query';\n      if (req.oauth2.req) {\n        var type = new UnorderedList(req.oauth2.req.type);\n        // In accordance with [OAuth 2.0 Multiple Response Type Encoding\n        // Practices - draft 08](http://openid.net/specs/oauth-v2-multiple-response-types-1_0.html),\n        // if the response type contains any value that requires fragment\n        // encoding, the response will be fragment encoded.\n        if (type.containsAny(fragment)) { enc = 'fragment'; }\n        if (req.oauth2.req.responseMode) {\n          // Encode the response using the requested mode, if specified.\n          enc = req.oauth2.req.responseMode;\n        }\n      }\n\n      var respond = modes[enc]\n        , params = {};\n\n      if (!respond) { return next(err); }\n\n      params.error = err.code || 'server_error';\n      if (err.message) { params.error_description = err.message; }\n      if (err.uri) { params.error_uri = err.uri; }\n      if (req.oauth2.req && req.oauth2.req.state) { params.state = req.oauth2.req.state; }\n      return respond(req.oauth2, res, params);\n    } else {\n      return next(err);\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-oauth2orize/node_modules/oauth2orize/lib/grant/code.js":"/**\n * Module dependencies.\n */\nvar url = require('url')\n  , AuthorizationError = require('../errors/authorizationerror');\n\n\n/**\n * Handles requests to obtain a grant in the form of an authorization code.\n *\n * Callbacks:\n *\n * This middleware requires an `issue` callback, for which the function\n * signature is as follows:\n *\n *     function(client, redirectURI, user, ares, done) { ... }\n *\n * `client` is the client instance making the authorization request.\n * `redirectURI` is the redirect URI specified by the client, and used as a\n * verifier in the subsequent access token exchange.  `user` is the\n * authenticated user approving the request.  `ares` is any additional\n * parameters parsed from the user's decision, including scope, duration of\n * access, etc.  `done` is called to issue an authorization code:\n *\n *     done(err, code)\n *\n * `code` is the code that will be sent to the client.  If an error occurs,\n * `done` should be invoked with `err` set in idomatic Node.js fashion.\n *\n * The code issued in this step will be used by the client in exchange for an\n * access token.  This code is bound to the client identifier and redirection\n * URI, which is included in the token request for verification.  The code is a\n * single-use token, and should expire shortly after it is issued (the maximum\n * recommended lifetime is 10 minutes).\n *\n * Options:\n *\n *     scopeSeparator  separator used to demarcate scope values (default: ' ')\n *\n * Examples:\n *\n *     server.grant(oauth2orize.grant.code(function(client, redirectURI, user, ares, done) {\n *       AuthorizationCode.create(client.id, redirectURI, user.id, ares.scope, function(err, code) {\n *         if (err) { return done(err); }\n *         done(null, code);\n *       });\n *     }));\n *\n * References:\n *  - [Authorization Code](http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-1.3.1)\n *  - [Authorization Code Grant](http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-4.1)\n *\n * @param {Object} options\n * @param {Function} issue\n * @return {Object} module\n * @api public\n */\nmodule.exports = function code(options, issue) {\n  if (typeof options == 'function') {\n    issue = options;\n    options = undefined;\n  }\n  options = options || {};\n  \n  if (!issue) { throw new TypeError('oauth2orize.code grant requires an issue callback'); }\n  \n  var modes = options.modes || {};\n  if (!modes.query) {\n    modes.query = require('../response/query');\n  }\n  \n  // For maximum flexibility, multiple scope spearators can optionally be\n  // allowed.  This allows the server to accept clients that separate scope\n  // with either space or comma (' ', ',').  This violates the specification,\n  // but achieves compatibility with existing client libraries that are already\n  // deployed.\n  var separators = options.scopeSeparator || ' ';\n  if (!Array.isArray(separators)) {\n    separators = [ separators ];\n  }\n  \n  \n  /* Parse requests that request `code` as `response_type`.\n   *\n   * @param {http.ServerRequest} req\n   * @api public\n   */\n  function request(req) {\n    var clientID = req.query.client_id\n      , redirectURI = req.query.redirect_uri\n      , scope = req.query.scope\n      , state = req.query.state;\n      \n    if (!clientID) { throw new AuthorizationError('Missing required parameter: client_id', 'invalid_request'); }\n    if (typeof clientID !== 'string') { throw new AuthorizationError('Invalid parameter: client_id must be a string', 'invalid_request'); }\n    \n    if (scope) {\n      if (typeof scope !== 'string') {\n        throw new AuthorizationError('Invalid parameter: scope must be a string', 'invalid_request');\n      }\n\n      for (var i = 0, len = separators.length; i < len; i++) {\n        var separated = scope.split(separators[i]);\n        // only separate on the first matching separator.  this allows for a sort\n        // of separator \"priority\" (ie, favor spaces then fallback to commas)\n        if (separated.length > 1) {\n          scope = separated;\n          break;\n        }\n      }\n      \n      if (!Array.isArray(scope)) { scope = [ scope ]; }\n    }\n    \n    return {\n      clientID: clientID,\n      redirectURI: redirectURI,\n      scope: scope,\n      state: state\n    };\n  }\n  \n  /* Sends responses to transactions that request `code` as `response_type`.\n   *\n   * @param {Object} txn\n   * @param {http.ServerResponse} res\n   * @param {Function} next\n   * @api public\n   */\n  function response(txn, res, complete, next) {\n    var mode = 'query'\n      , respond;\n    if (txn.req && txn.req.responseMode) {\n      mode = txn.req.responseMode;\n    }\n    respond = modes[mode];\n    \n    if (!respond) {\n      // http://lists.openid.net/pipermail/openid-specs-ab/Week-of-Mon-20140317/004680.html\n      return next(new AuthorizationError('Unsupported response mode: ' + mode, 'unsupported_response_mode', null, 501));\n    }\n    if (respond && respond.validate) {\n      try {\n        respond.validate(txn);\n      } catch(ex) {\n        return next(ex);\n      }\n    }\n    \n    if (!txn.res.allow) {\n      var params = { error: 'access_denied' };\n      if (txn.req && txn.req.state) { params.state = txn.req.state; }\n      return respond(txn, res, params);\n    }\n    \n    function issued(err, code) {\n      if (err) { return next(err); }\n      if (!code) { return next(new AuthorizationError('Request denied by authorization server', 'access_denied')); }\n      \n      var params = { code: code };\n      if (txn.req && txn.req.state) { params.state = txn.req.state; }\n      complete(function(err) {\n        if (err) { return next(err); }\n        return respond(txn, res, params);\n      });\n    }\n    \n    // NOTE: The `redirect_uri`, if present in the client's authorization\n    //       request, must also be present in the subsequent request to exchange\n    //       the authorization code for an access token.  Acting as a verifier,\n    //       the two values must be equal and serve to protect against certain\n    //       types of attacks.  More information can be found here:\n    //\n    //       http://hueniverse.com/2011/06/oauth-2-0-redirection-uri-validation/\n    \n    try {\n      var arity = issue.length;\n      if (arity == 7) {\n        issue(txn.client, txn.req.redirectURI, txn.user, txn.res, txn.req, txn.locals, issued);\n      } else if (arity == 6) {\n        issue(txn.client, txn.req.redirectURI, txn.user, txn.res, txn.req, issued);\n      } else if (arity == 5) {\n        issue(txn.client, txn.req.redirectURI, txn.user, txn.res, issued);\n      } else { // arity == 4\n        issue(txn.client, txn.req.redirectURI, txn.user, issued);\n      }\n    } catch (ex) {\n      return next(ex);\n    }\n  }\n  \n  function errorHandler(err, txn, res, next) {\n    var mode = 'query'\n      , params = {}\n      , respond;\n    if (txn.req && txn.req.responseMode) {\n      mode = txn.req.responseMode;\n    }\n    respond = modes[mode];\n    \n    if (!respond) {\n      return next(err);\n    }\n    if (respond && respond.validate) {\n      try {\n        respond.validate(txn);\n      } catch(ex) {\n        return next(err);\n      }\n    }\n    \n    params.error = err.code || 'server_error';\n    if (err.message) { params.error_description = err.message; }\n    if (err.uri) { params.error_uri = err.uri; }\n    if (txn.req && txn.req.state) { params.state = txn.req.state; }\n    return respond(txn, res, params);\n  }\n  \n  \n  /**\n   * Return `code` approval module.\n   */\n  var mod = {};\n  mod.name = 'code';\n  mod.request = request;\n  mod.response = response;\n  mod.error = errorHandler;\n  return mod;\n};\n","/home/travis/build/npmtest/node-npmtest-oauth2orize/node_modules/oauth2orize/lib/grant/token.js":"/**\n * Module dependencies.\n */\nvar url = require('url')\n  , qs = require('querystring')\n  , utils = require('../utils')\n  , AuthorizationError = require('../errors/authorizationerror');\n\n\n/**\n * Handles requests to obtain an implicit grant.\n *\n * Callbacks:\n *\n * This middleware requires an `issue` callback, for which the function\n * signature is as follows:\n *\n *     function(client, user, ares, done) { ... }\n *\n * `client` is the client instance making the authorization request.  `user` is\n * the authenticated user approving the request.  `ares` is any additional\n * parameters parsed from the user's decision, including scope, duration of\n * access, etc.  `done` is called to issue an access token:\n *\n *     done(err, accessToken, params)\n *\n * `accessToken` is the access token that will be sent to the client.\n * Optionally, any additional `params` will be included in the response.  If an\n * error occurs, `done` should be invoked with `err` set in idomatic Node.js\n * fashion.\n *\n * Implicit grants do not include client authentication, and rely on the\n * registration of the redirect URI.  Applications can enforce this constraint\n * in the `validate` callback of `authorization` middleware.\n *\n * Options:\n *\n *     scopeSeparator  separator used to demarcate scope values (default: ' ')\n *\n * Examples:\n *\n *     server.grant(oauth2orize.grant.token(function(client, user, ares, done) {}\n *       AccessToken.create(client, user, ares.scope, function(err, accessToken) {\n *         if (err) { return done(err); }\n *         done(null, accessToken);\n *       });\n *     }));\n *\n * References:\n *  - [Implicit](http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-1.3.2)\n *  - [Implicit Grant](http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-4.2)\n *\n * @param {Object} options\n * @param {Function} issue\n * @return {Object} module\n * @api public\n */\nmodule.exports = function token(options, issue) {\n  if (typeof options == 'function') {\n    issue = options;\n    options = undefined;\n  }\n  options = options || {};\n  \n  if (!issue) { throw new TypeError('oauth2orize.token grant requires an issue callback'); }\n  \n  var modes = options.modes || {};\n  if (!modes.fragment) {\n    modes.fragment = require('../response/fragment');\n  }\n  \n  // For maximum flexibility, multiple scope spearators can optionally be\n  // allowed.  This allows the server to accept clients that separate scope\n  // with either space or comma (' ', ',').  This violates the specification,\n  // but achieves compatibility with existing client libraries that are already\n  // deployed.\n  var separators = options.scopeSeparator || ' ';\n  if (!Array.isArray(separators)) {\n    separators = [ separators ];\n  }\n  \n  \n  /* Parse requests that request `token` as `response_type`.\n   *\n   * @param {http.ServerRequest} req\n   * @api public\n   */\n  function request(req) {\n    var clientID = req.query.client_id\n      , redirectURI = req.query.redirect_uri\n      , scope = req.query.scope\n      , state = req.query.state;\n      \n    if (!clientID) { throw new AuthorizationError('Missing required parameter: client_id', 'invalid_request'); }\n    if (typeof clientID !== 'string') { throw new AuthorizationError('Invalid parameter: client_id must be a string', 'invalid_request'); }\n    \n    if (scope) {\n      if (typeof scope !== 'string') {\n        throw new AuthorizationError('Invalid parameter: scope must be a string', 'invalid_request');\n      }\n\n      for (var i = 0, len = separators.length; i < len; i++) {\n        var separated = scope.split(separators[i]);\n        // only separate on the first matching separator.  this allows for a sort\n        // of separator \"priority\" (ie, favor spaces then fallback to commas)\n        if (separated.length > 1) {\n          scope = separated;\n          break;\n        }\n      }\n      \n      if (!Array.isArray(scope)) { scope = [ scope ]; }\n    }\n    \n    return {\n      clientID: clientID,\n      redirectURI: redirectURI,\n      scope: scope,\n      state: state\n    };\n  }\n  \n  /* Sends responses to transactions that request `token` as `response_type`.\n   *\n   * @param {Object} txn\n   * @param {http.ServerResponse} res\n   * @param {Function} next\n   * @api public\n   */\n  function response(txn, res, complete, next) {\n    var mode = 'fragment'\n      , respond;\n    if (txn.req && txn.req.responseMode) {\n      mode = txn.req.responseMode;\n    }\n    respond = modes[mode];\n    \n    if (!respond) {\n      // http://lists.openid.net/pipermail/openid-specs-ab/Week-of-Mon-20140317/004680.html\n      return next(new AuthorizationError('Unsupported response mode: ' + mode, 'unsupported_response_mode', null, 501));\n    }\n    if (respond && respond.validate) {\n      try {\n        respond.validate(txn);\n      } catch(ex) {\n        return next(ex);\n      }\n    }\n    \n    if (!txn.res.allow) {\n      var params = { error: 'access_denied' };\n      if (txn.req && txn.req.state) { params.state = txn.req.state; }\n      return respond(txn, res, params);\n    }\n    \n    function issued(err, accessToken, params) {\n      if (err) { return next(err); }\n      if (!accessToken) { return next(new AuthorizationError('Request denied by authorization server', 'access_denied')); }\n      \n      var tok = {};\n      tok.access_token = accessToken;\n      if (params) { utils.merge(tok, params); }\n      tok.token_type = tok.token_type || 'Bearer';\n      if (txn.req && txn.req.state) { tok.state = txn.req.state; }\n      complete(function(err) {\n        if (err) { return next(err); }\n        return respond(txn, res, tok);\n      });\n    }\n    \n    // NOTE: In contrast to an authorization code grant, redirectURI is not\n    //       passed as an argument to the issue callback because it is not used\n    //       as a verifier in a subsequent token exchange.  However, when\n    //       issuing an implicit access tokens, an application must ensure that\n    //       the redirection URI is registered, which can be done in the\n    //       `validate` callback of `authorization` middleware.\n    \n    try {\n      var arity = issue.length;\n      if (arity == 6) {\n        issue(txn.client, txn.user, txn.res, txn.req, txn.locals, issued);\n      } else if (arity == 5) {\n        issue(txn.client, txn.user, txn.res, txn.req, issued);\n      } else if (arity == 4) {\n        issue(txn.client, txn.user, txn.res, issued);\n      } else { // arity == 3\n        issue(txn.client, txn.user, issued);\n      }\n    } catch (ex) {\n      return next(ex);\n    }\n  }\n  \n  function errorHandler(err, txn, res, next) {\n    var mode = 'fragment'\n      , params = {}\n      , respond;\n    if (txn.req && txn.req.responseMode) {\n      mode = txn.req.responseMode;\n    }\n    respond = modes[mode];\n    \n    if (!respond) {\n      return next(err);\n    }\n    if (respond && respond.validate) {\n      try {\n        respond.validate(txn);\n      } catch(ex) {\n        return next(err);\n      }\n    }\n    \n    params.error = err.code || 'server_error';\n    if (err.message) { params.error_description = err.message; }\n    if (err.uri) { params.error_uri = err.uri; }\n    if (txn.req && txn.req.state) { params.state = txn.req.state; }\n    return respond(txn, res, params);\n  }\n  \n  \n  /**\n   * Return `token` approval module.\n   */\n  var mod = {};\n  mod.name = 'token';\n  mod.request = request;\n  mod.response = response;\n  mod.error = errorHandler;\n  return mod;\n};\n","/home/travis/build/npmtest/node-npmtest-oauth2orize/node_modules/oauth2orize/lib/exchange/authorizationCode.js":"/**\n * Module dependencies.\n */\nvar utils = require('../utils')\n  , TokenError = require('../errors/tokenerror');\n\n\n/**\n * Exchanges authorization codes for access tokens.\n *\n * This exchange middleware is used to by clients to obtain an access token by\n * presenting an authorization code.  An authorization code must have previously\n * been issued, as handled by `code` grant middleware.\n *\n * Callbacks:\n *\n * This middleware requires an `issue` callback, for which the function\n * signature is as follows:\n *\n *     function(client, code, redirectURI, done) { ... }\n *\n * `client` is the authenticated client instance attempting to obtain an access\n * token.  `code` is the authorization code the client is in possession of.\n * `redirectURI` is the redirect URI specified by the client, being used as a\n * verifier which must match the value in the initial authorization request.\n * `done` is called to issue an access token:\n *\n *     done(err, accessToken, refreshToken, params)\n *\n * `accessToken` is the access token that will be sent to the client.  An\n * optional `refreshToken` will be sent to the client, if the server chooses to\n * implement support for this functionality.  Any additional `params` will be\n * included in the response.  If an error occurs, `done` should be invoked with\n * `err` set in idomatic Node.js fashion.\n *\n * Options:\n *\n *     userProperty   property of `req` which contains the authenticated client (default: 'user')\n *\n * Examples:\n *\n *     server.exchange(oauth2orize.exchange.authorizationCode(function(client, code, redirectURI, done) {\n *       AccessToken.create(client, code, redirectURI, function(err, accessToken) {\n *         if (err) { return done(err); }\n *         done(null, accessToken);\n *       });\n *     }));\n *\n * References:\n *  - [Authorization Code](http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-1.3.1)\n *  - [Authorization Code Grant](http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-4.1)\n *\n * @param {Object} options\n * @param {Function} issue\n * @return {Function}\n * @api public\n */\nmodule.exports = function(options, issue) {\n  if (typeof options == 'function') {\n    issue = options;\n    options = undefined;\n  }\n  options = options || {};\n  \n  if (!issue) { throw new TypeError('oauth2orize.authorizationCode exchange requires an issue callback'); }\n  \n  var userProperty = options.userProperty || 'user';\n\n  return function authorization_code(req, res, next) {\n    if (!req.body) { return next(new Error('OAuth2orize requires body parsing. Did you forget app.use(express.bodyParser())?')); }\n    \n    // The 'user' property of `req` holds the authenticated user.  In the case\n    // of the token endpoint, the property will contain the OAuth 2.0 client.\n    var client = req[userProperty]\n      , code = req.body.code\n      , redirectURI = req.body.redirect_uri;\n      \n    if (!code) { return next(new TokenError('Missing required parameter: code', 'invalid_request')); }\n    \n    function issued(err, accessToken, refreshToken, params) {\n      if (err) { return next(err); }\n      if (!accessToken) { return next(new TokenError('Invalid authorization code', 'invalid_grant')); }\n      if (refreshToken && typeof refreshToken == 'object') {\n        params = refreshToken;\n        refreshToken = null;\n      }\n\n      var tok = {};\n      tok.access_token = accessToken;\n      if (refreshToken) { tok.refresh_token = refreshToken; }\n      if (params) { utils.merge(tok, params); }\n      tok.token_type = tok.token_type || 'Bearer';\n\n      var json = JSON.stringify(tok);\n      res.setHeader('Content-Type', 'application/json');\n      res.setHeader('Cache-Control', 'no-store');\n      res.setHeader('Pragma', 'no-cache');\n      res.end(json);\n    }\n    \n    try {\n      var arity = issue.length;\n      if (arity == 6) {\n        issue(client, code, redirectURI, req.body, req.authInfo, issued);\n      } else if (arity == 5) {\n        issue(client, code, redirectURI, req.body, issued);\n      } else { // arity == 4\n        issue(client, code, redirectURI, issued);\n      }\n    } catch (ex) {\n      return next(ex);\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-oauth2orize/node_modules/oauth2orize/lib/exchange/clientCredentials.js":"/**\n * Module dependencies.\n */\nvar utils = require('../utils')\n  , TokenError = require('../errors/tokenerror');\n\n\n/**\n * Exchanges client credentials for access tokens.\n *\n * This exchange middleware is used to by clients to obtain an access token by\n * presenting client credentials.\n *\n * Callbacks:\n *\n * This middleware requires an `issue` callback, for which the function\n * signature is as follows:\n *\n *     function(client, scope, body, authInfo, done) { ... }\n *\n * `client` is the authenticated client instance attempting to obtain an access\n * token.  `scope` is the scope of access requested by the client.  `done` is\n * called to issue an access token:\n *\n *     done(err, accessToken, [refreshToken], [params])\n *\n * `accessToken` is the access token that will be sent to the client.  An\n * optional `refreshToken` will be sent to the client, if the server chooses to\n * implement support for this functionality (note that the spec says a refresh\n * token should not be included).  Any additional `params` will be included in\n * the response.  If an error occurs, `done` should be invoked with `err` set in\n * idomatic Node.js fashion.\n *\n * Options:\n *\n *     userProperty    property of `req` which contains the authenticated client (default: 'user')\n *     scopeSeparator  separator used to demarcate scope values (default: ' ')\n *\n * Examples:\n *\n *     server.exchange(oauth2orize.exchange.clientCredentials(function(client, scope, done) {\n *       AccessToken.create(client, scope, function(err, accessToken) {\n *         if (err) { return done(err); }\n *         done(null, accessToken);\n *       });\n *     }));\n *\n * References:\n *  - [Client Credentials](http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-1.3.4)\n *  - [Client Credentials Grant](http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-4.4)\n *\n * @param {Object} options\n * @param {Function} issue\n * @return {Function}\n * @api public\n */\nmodule.exports = function(options, issue) {\n  if (typeof options == 'function') {\n    issue = options;\n    options = undefined;\n  }\n  options = options || {};\n  \n  if (!issue) { throw new TypeError('oauth2orize.clientCredentials exchange requires an issue callback'); }\n\n  var userProperty = options.userProperty || 'user';\n\n  // For maximum flexibility, multiple scope spearators can optionally be\n  // allowed.  This allows the server to accept clients that separate scope\n  // with either space or comma (' ', ',').  This violates the specification,\n  // but achieves compatibility with existing client libraries that are already\n  // deployed.\n  var separators = options.scopeSeparator || ' ';\n  if (!Array.isArray(separators)) {\n    separators = [ separators ];\n  }\n\n  return function client_credentials(req, res, next) {\n    if (!req.body) { return next(new Error('OAuth2orize requires body parsing. Did you forget app.use(express.bodyParser())?')); }\n    \n    // The 'user' property of `req` holds the authenticated user.  In the case\n    // of the token endpoint, the property will contain the OAuth 2.0 client.\n    var client = req[userProperty]\n      , scope = req.body.scope;\n    \n    if (scope) {\n      for (var i = 0, len = separators.length; i < len; i++) {\n        var separated = scope.split(separators[i]);\n        // only separate on the first matching separator.  this allows for a sort\n        // of separator \"priority\" (ie, favor spaces then fallback to commas)\n        if (separated.length > 1) {\n          scope = separated;\n          break;\n        }\n      }\n      if (!Array.isArray(scope)) { scope = [ scope ]; }\n    }\n    \n    function issued(err, accessToken, refreshToken, params) {\n      if (err) { return next(err); }\n      if (!accessToken) { return next(new TokenError('Invalid client credentials', 'invalid_grant')); }\n      if (refreshToken && typeof refreshToken == 'object') {\n        params = refreshToken;\n        refreshToken = null;\n      }\n\n      var tok = {};\n      tok.access_token = accessToken;\n      if (refreshToken) { tok.refresh_token = refreshToken; }\n      if (params) { utils.merge(tok, params); }\n      tok.token_type = tok.token_type || 'Bearer';\n      \n      var json = JSON.stringify(tok);\n      res.setHeader('Content-Type', 'application/json');\n      res.setHeader('Cache-Control', 'no-store');\n      res.setHeader('Pragma', 'no-cache');\n      res.end(json);\n    }\n    \n    try {\n      var arity = issue.length;\n      if (arity == 5) {\n        issue(client, scope, req.body, req.authInfo, issued);\n      } else if (arity == 4) {\n        issue(client, scope, req.body, issued);\n      } else if (arity == 3) {\n        issue(client, scope, issued);\n      } else { // arity == 2\n        issue(client, issued);\n      }\n    } catch (ex) {\n      return next(ex);\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-oauth2orize/node_modules/oauth2orize/lib/exchange/password.js":"/**\n * Module dependencies.\n */\nvar utils = require('../utils')\n  , TokenError = require('../errors/tokenerror');\n\n\n/**\n * Exchanges resource owner password credentials for access tokens.\n *\n * This exchange middleware is used to by clients to obtain an access token by\n * presenting the resource owner's password credentials.  These credentials are\n * typically obtained directly from the user, by prompting them for input.\n *\n * Callbacks:\n *\n * This middleware requires an `issue` callback, for which the function\n * signature is as follows:\n *\n *     function(client, username, password, scope, body, authInfo, done) { ... }\n *\n * `client` is the authenticated client instance attempting to obtain an access\n * token.  `username` and `password` and the resource owner's credentials.\n * `scope` is the scope of access requested by the client.  `done` is called to\n * issue an access token:\n *\n *     done(err, accessToken, refreshToken, params)\n *\n * `accessToken` is the access token that will be sent to the client.  An\n * optional `refreshToken` will be sent to the client, if the server chooses to\n * implement support for this functionality.  Any additional `params` will be\n * included in the response.  If an error occurs, `done` should be invoked with\n * `err` set in idomatic Node.js fashion.\n *\n * Options:\n *\n *     userProperty    property of `req` which contains the authenticated client (default: 'user')\n *     scopeSeparator  separator used to demarcate scope values (default: ' ')\n *\n * Examples:\n *\n *     server.exchange(oauth2orize.exchange.password(function(client, username, password, scope, done) {\n *       AccessToken.create(client, username, password, scope, function(err, accessToken) {\n *         if (err) { return done(err); }\n *         done(null, accessToken);\n *       });\n *     }));\n *\n * References:\n *  - [Resource Owner Password Credentials](http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-1.3.3)\n *  - [Resource Owner Password Credentials Grant](http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-4.3)\n *\n * @param {Object} options\n * @param {Function} issue\n * @return {Function}\n * @api public\n */\nmodule.exports = function(options, issue) {\n  if (typeof options == 'function') {\n    issue = options;\n    options = undefined;\n  }\n  options = options || {};\n\n  if (!issue) { throw new TypeError('oauth2orize.password exchange requires an issue callback'); }\n\n  var userProperty = options.userProperty || 'user';\n\n  // For maximum flexibility, multiple scope spearators can optionally be\n  // allowed.  This allows the server to accept clients that separate scope\n  // with either space or comma (' ', ',').  This violates the specification,\n  // but achieves compatibility with existing client libraries that are already\n  // deployed.\n  var separators = options.scopeSeparator || ' ';\n  if (!Array.isArray(separators)) {\n    separators = [ separators ];\n  }\n\n  return function password(req, res, next) {\n    if (!req.body) { return next(new Error('OAuth2orize requires body parsing. Did you forget app.use(express.bodyParser())?')); }\n    \n    // The 'user' property of `req` holds the authenticated user.  In the case\n    // of the token endpoint, the property will contain the OAuth 2.0 client.\n    var client = req[userProperty]\n      , username = req.body.username\n      , passwd = req.body.password\n      , scope = req.body.scope;\n      \n    if (!username) { return next(new TokenError('Missing required parameter: username', 'invalid_request')); }\n    if (!passwd) { return next(new TokenError('Missing required parameter: password', 'invalid_request')); }\n    \n    if (scope) {\n      for (var i = 0, len = separators.length; i < len; i++) {\n        var separated = scope.split(separators[i]);\n        // only separate on the first matching separator.  this allows for a sort\n        // of separator \"priority\" (ie, favor spaces then fallback to commas)\n        if (separated.length > 1) {\n          scope = separated;\n          break;\n        }\n      }\n      if (!Array.isArray(scope)) { scope = [ scope ]; }\n    }\n    \n    function issued(err, accessToken, refreshToken, params) {\n      if (err) { return next(err); }\n      if (!accessToken) { return next(new TokenError('Invalid resource owner credentials', 'invalid_grant')); }\n      if (refreshToken && typeof refreshToken == 'object') {\n        params = refreshToken;\n        refreshToken = null;\n      }\n      \n      var tok = {};\n      tok.access_token = accessToken;\n      if (refreshToken) { tok.refresh_token = refreshToken; }\n      if (params) { utils.merge(tok, params); }\n      tok.token_type = tok.token_type || 'Bearer';\n      \n      var json = JSON.stringify(tok);\n      res.setHeader('Content-Type', 'application/json');\n      res.setHeader('Cache-Control', 'no-store');\n      res.setHeader('Pragma', 'no-cache');\n      res.end(json);\n    }\n\n    try {\n      var arity = issue.length;\n      if (arity == 7) {\n        issue(client, username, passwd, scope, req.body, req.authInfo, issued);\n      } else if (arity == 6) {\n        issue(client, username, passwd, scope, req.body, issued);\n      } else if (arity == 5) {\n        issue(client, username, passwd, scope, issued);\n      } else { // arity == 4\n        issue(client, username, passwd, issued);\n      }\n    } catch (ex) {\n      return next(ex);\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-oauth2orize/node_modules/oauth2orize/lib/exchange/refreshToken.js":"/**\n * Module dependencies.\n */\nvar utils = require('../utils')\n  , TokenError = require('../errors/tokenerror');\n\n\n/**\n * Refresh previously issued access tokens.\n *\n * This exchange middleware is used to by clients to refresh an access token by\n * using a refresh token issued by the server.\n *\n * Callbacks:\n *\n * This middleware requires an `issue` callback, for which the function\n * signature is as follows:\n *\n *     function(client, refreshToken, scope, done) { ... }\n *\n * `client` is the authenticated client instance attempting to obtain an access\n * token.  `refreshToken` is the refresh token issued by the server.  `scope` is\n * the scope of access requested by the client, which must not include any scope\n * not originally granted.  `done` is called to issue an access token:\n *\n *     done(err, accessToken, refreshToken, params)\n *\n * `accessToken` is the access token that will be sent to the client.  An\n * optional `refreshToken` will be sent to the client, if the server chooses to\n * implement support for this functionality.  Any additional `params` will be\n * included in the response.  If an error occurs, `done` should be invoked with\n * `err` set in idomatic Node.js fashion.\n *\n * Options:\n *\n *     userProperty    property of `req` which contains the authenticated client (default: 'user')\n *     scopeSeparator  separator used to demarcate scope values (default: ' ')\n *\n * Examples:\n *\n *     server.exchange(oauth2orize.exchange.refreshToken(function(client, refreshToken, scope, done) {\n *       AccessToken.create(client, refreshToken, scope, function(err, accessToken) {\n *         if (err) { return done(err); }\n *         done(null, accessToken);\n *       });\n *     }));\n *\n * References:\n *  - [Refreshing an Access Token](http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-6)\n *\n * @param {Object} options\n * @param {Function} issue\n * @api public\n */\nmodule.exports = function(options, issue) {\n  if (typeof options == 'function') {\n    issue = options;\n    options = undefined;\n  }\n  options = options || {};\n  \n  if (!issue) { throw new TypeError('oauth2orize.refreshToken exchange requires an issue callback'); }\n  \n  var userProperty = options.userProperty || 'user';\n\n  // For maximum flexibility, multiple scope spearators can optionally be\n  // allowed.  This allows the server to accept clients that separate scope\n  // with either space or comma (' ', ',').  This violates the specification,\n  // but achieves compatibility with existing client libraries that are already\n  // deployed.\n  var separators = options.scopeSeparator || ' ';\n  if (!Array.isArray(separators)) {\n    separators = [ separators ];\n  }\n\n  return function refresh_token(req, res, next) {\n    if (!req.body) { return next(new Error('OAuth2orize requires body parsing. Did you forget app.use(express.bodyParser())?')); }\n    \n    // The 'user' property of `req` holds the authenticated user.  In the case\n    // of the token endpoint, the property will contain the OAuth 2.0 client.\n    var client = req[userProperty]\n      , refreshToken = req.body.refresh_token\n      , scope = req.body.scope;\n      \n    if (!refreshToken) { return next(new TokenError('Missing required parameter: refresh_token', 'invalid_request')); }\n    \n    if (scope) {\n      for (var i = 0, len = separators.length; i < len; i++) {\n        var separated = scope.split(separators[i]);\n        // only separate on the first matching separator.  this allows for a sort\n        // of separator \"priority\" (ie, favor spaces then fallback to commas)\n        if (separated.length > 1) {\n          scope = separated;\n          break;\n        }\n      }\n      if (!Array.isArray(scope)) { scope = [ scope ]; }\n    }\n    \n    function issued(err, accessToken, refreshToken, params) {\n      if (err) { return next(err); }\n      if (!accessToken) { return next(new TokenError('Invalid refresh token', 'invalid_grant')); }\n      if (refreshToken && typeof refreshToken == 'object') {\n        params = refreshToken;\n        refreshToken = null;\n      }\n      \n      var tok = {};\n      tok.access_token = accessToken;\n      if (refreshToken) { tok.refresh_token = refreshToken; }\n      if (params) { utils.merge(tok, params); }\n      tok.token_type = tok.token_type || 'Bearer';\n      \n      var json = JSON.stringify(tok);\n      res.setHeader('Content-Type', 'application/json');\n      res.setHeader('Cache-Control', 'no-store');\n      res.setHeader('Pragma', 'no-cache');\n      res.end(json);\n    }\n    \n    try {\n      var arity = issue.length;\n      if (arity == 6) {\n        issue(client, refreshToken, scope, req.body, req.authInfo, issued);\n      } else if (arity == 5) {\n        issue(client, refreshToken, scope, req.body, issued);\n      } else if (arity == 4) {\n        issue(client, refreshToken, scope, issued);\n      } else { // arity == 3\n        issue(client, refreshToken, issued);\n      }\n    } catch (ex) {\n      return next(ex);\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-oauth2orize/node_modules/oauth2orize/lib/response/fragment.js":"var url = require('url')\n  , qs = require('querystring')\n  , AuthorizationError = require('../errors/authorizationerror');\n\n/**\n* Authorization Response parameters are encoded in the fragment added to the redirect_uri when \n* redirecting back to the Client.\n**/\nexports = module.exports = function (txn, res, params) {\n  var parsed = url.parse(txn.redirectURI);\n  parsed.hash = qs.stringify(params);\n\n  var location = url.format(parsed);\n  return res.redirect(location);\n};\n\n\nexports.validate = function(txn) {\n  if (!txn.redirectURI) { throw new AuthorizationError('Unable to issue redirect for OAuth 2.0 transaction', 'server_error'); }\n};\n","/home/travis/build/npmtest/node-npmtest-oauth2orize/node_modules/oauth2orize/lib/response/query.js":"var url = require('url')\n  , AuthorizationError = require('../errors/authorizationerror');\n\n/**\n* Authorization Response parameters are encoded in the query string added to the redirect_uri when \n* redirecting back to the Client.\n**/\nexports = module.exports = function (txn, res, params) {\n  var parsed = url.parse(txn.redirectURI, true);\n  delete parsed.search;\n  Object.keys(params).forEach(function (k) {\n    parsed.query[k] = params[k];\n  });\n\n  var location = url.format(parsed);\n  return res.redirect(location);\n};\n\nexports.validate = function(txn) {\n  if (!txn.redirectURI) { throw new AuthorizationError('Unable to issue redirect for OAuth 2.0 transaction', 'server_error'); }\n};\n"}